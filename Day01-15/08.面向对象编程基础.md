## 面向对象编程基础

活在当下的程序员应该都听过&quot;面向对象编程&quot;一词，也经常有人问能不能用一句话解释下什么是&quot;面向对象编程&quot;，我们先来看看比较正式的说法。

&quot;把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。&quot;

这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于[知乎](https://www.zhihu.com/)。

![](./res/oop-zhihu.png)

> **说明：** 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。

之前我们说过&quot;**程序是指令的集合**&quot;，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，&quot;每个人都应该学习编程&quot;这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，&quot;[软件危机](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA)&quot;、&quot;[软件工程](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B)&quot;等一系列的概念开始在行业中出现。

当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的&quot;[银弹](https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9)&quot;，真正让软件开发者看到希望的是上世纪70年代诞生的[Smalltalk](https://zh.wikipedia.org/wiki/Smalltalk)编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的[Simula](https://zh.wikipedia.org/wiki/Simula)语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。

> **说明：** 当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。

### 类和对象

简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。

![](./res/object-feature.png)

## 定义类

在Python中可以使用`class`关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。

```Python
class Student(object):

    # __init__是一个特殊方法用于在创建对象时进行初始化操作
    # 通过这个方法我们可以为学生对象绑定name和age两个属性
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def study(self, course_name):
        print('%s正在学习%s.' % (self.name, course_name))

    # PEP 8要求标识符的名字用全小写多个单词用下划线连接
    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)
    def watch_movie(self):
        if self.age < 18:
            print('%s只能观看《熊出没》.' % self.name)
        else:
            print('%s正在观看岛国爱情大电影.' % self.name)
```

> **说明：** 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。

```python
class Car:
    def infor(self):
        print("This is a car")

car=Car()
car.infor()
#This is a car
```

在Python中，可以使用内置方法```isinstance()```来测试一个对象是否为某个类的示例

```python
print(isinstance(car,Car))
#True
print(isinstance(car,str))
#False
```

在python中提供了一个关键字pass，类似于空语句。

```python
class A:
    pass
def demo():
    pass
if 5>3:
    pass
```

#### self参数

内的所有实例方法都必须至少有一个名为```self```的参数,并且必须是方法的第一个形参，self参数代表对象本身。在类的实例方法中访问实例属性是需要以```self```为前缀，但在外部通过对象名调用对象方法时并不用传递这个参数，如果在外部通过类名调用方法时通过类名调用对象方法则需要显示为```self```参数传值。

```python
class A:
    def __init__(self,v):
        self.value = v
    def show(self):
        print(self.value)

a = A(3)
a.show()			#3
```

### 类成员与实例成员

属性有两种：一种是实例属性；另一种是类属性。

实例属性一般是指在构造函数``` __init__() ``` 中定义的，定义和使用时必须以```self```作为前缀；

类属性是在类中所有方法之外定义的数据成员。在主程序中（或类的外部），实例属性属于实例（对象），只能通过对象名访问；而类属性属于类可以通过类名或对象名访问。

在类的方法中可以调用类本身的其他方法，也可以访问类属性以及对象属性。在Python中比较特殊的是，可以动态地位类和对象增加成员。

```python
class Car:
    price = 100000                  #定义类属性
    def __init__(self,c):
        self.color = c              #定义类实例属性
car1 = Car("Red")
car2 = Car("Blue")
print(car1.color,Car.price)
#Red 100000
Car.price = 110000                  #修改类属性
Car.name = "QQ"                     #增加类属性
car1.color = "Yellow"               #修改实例属性
print(car2.color,Car.price,Car.name)
#Blue 110000 QQ
print(car1.color,Car.price,Car.name)
#Yellow 110000 QQ

'''为类添加了一个成员方法'''
import types
def setSpeed(self,s):
    self.speed = s
car1.setSpeed = types.MethodType(setSpeed,Car)
car1.setSpeed(50)
print(car1.speed)				#50
```

在python中函数和方法是有区别的。方法一般指与特定实例绑定的函数，通过对象调用方法时对象本身作为第一个参数传递过去，普通函数并不具有这个特点。

```python
class Demo:
    pass
t = Demo()
def test(self,v):
    self.value = v
t.test = test
print(t.test)#<function test at 0x0000018D25597F70>
t.test(t,3)
print(t.value)			#3

import types
t.test = types.MethodType(test,t)
print(t.test)  	#<bound method test of <__main__.Demo object at 0x000001A09DF50FD0>>  
t.test(5)
print(t.value)#5
```

### 创建和使用对象

当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。

```Python
def main():
    # 创建学生对象并指定姓名和年龄
    stu1 = Student('骆昊', 38)
    # 给对象发study消息
    stu1.study('Python程序设计')
    # 给对象发watch_av消息
    stu1.watch_movie()
    stu2 = Student('王大锤', 15)
    stu2.study('思想品德')
    stu2.watch_movie()


if __name__ == '__main__':
    main()
```

### 访问可见性问题

对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给`Student`对象绑定的`name`和`age`属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。

```Python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    # AttributeError: 'Test' object has no attribute '__bar'
    test.__bar()
    # AttributeError: 'Test' object has no attribute '__foo'
    print(test.__foo)


if __name__ == "__main__":
    main()
```

但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是&quot;**We are all consenting adults here**&quot;。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。

```Python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    test._Test__bar()
    print(test._Test__foo)


if __name__ == "__main__":
    main()
```

在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的[《Python - 那些年我们踩过的那些坑》](http://blog.csdn.net/jackfrued/article/details/79521404)文章中的讲解。

在定义类的属性时，如果属性名以两条下划线“__”(中间无空)开头则表示时私有属性。私有属性在类的外部不能直接访问，需要通过调用对象的共有成员方法来访问，或者通过python支持的特殊方式来访问。私有属性时为了数据封装和保密而设置的属性，一般只能在类内访问。公有属性是可以公开使用的，既可以在类内访问，也可以在外部程序中访问。

```python
class A:
    def __init__(self,value1=0,value2=0):
        self._value1 = value1	#保护成员
        self.__value2 = value2	#类中的私有成员
    def setValue(self,value1,value2):
        self._value1 = value1
        self.__value2 = value2
    def show(self):
        print(self._value1)
        print(self.__value2)
a=A()
print(a._value1)		#0
print(a._A__value2)		#0
```

- _xxx	:这样的对象叫做保护成员，不能用“from module import *”导入，只有类对象和子类对象能访问

- __ xxx__ :系统定义的特殊成员
- __ xxx:类中的私有成员，只有类对象自己能访问，子类对象也不能访问到这个成员，但在对象外部可以通过“对象名._  _类名 __xxx”这样特殊方式来访问。 

下面代码演示了特殊成员定义和访问的方法

```python
class Fruit:
    def __init__(self):
        self.__color='Red'
        self.price=1
apple = Fruit()
print(apple.price)                       #1
apple.price = 2
print(apple.price,apple._Fruit__color)  #2 Red
apple._Fruit__color='Blue'
print(apple.price,apple._Fruit__color)  #2 Blue
```

##  方法

在类中定义的方法有四大类，公有方法，私有方法，静态方法，和类方法。共有方法和私有方法都属于对象，私有方法的名字以两个下划线“__”开始，每个类都有自己的公有和私有方法，在这两个方法中可以访问类和对象的成员；公有方法通过对象名直接调用，私有方法不能通过对象名直接调用，只能在属于对象的方法中通过```self```调用，或者在外部通过python支持的特殊方式来调用。如果通过类名来调用属于对象的公有方法，需要显示为该方法的```self```参数传递一个对象名，用来明确指定访问哪个对象的数据成员。静态方法和类方法都可以通过类名和对象名来调用，但不能直接访问属于对象的成员，只能访问属于类的成员。一般将cls作为类方法的第一个参数名称。

```python
class Root:
    __total = 0
    def __init__(self,v):
        self.__value = v
        Root.__total +=1
    def show(self):
        print('self.__value:',self.__value)
        print('Root.__total:',Root.__total)
    @classmethod #类方法
    def classShowTotal(cls):
        print(cls.__total)
    @staticmethod #静态方法
    def staticShowTotal():
        print(Root.__total)
r = Root(3)
r.classShowTotal()      #通过对象来调用类方法 #1
r.staticShowTotal()     #通过对象来调用静态方法 #1
r.show()
# self.__value: 3
# Root.__total: 1
rr = Root(5)
Root.classShowTotal()   #通过类名调用类方法
Root.staticShowTotal()  #通过类名调用静态方法
Root.show(r)
# self.__value: 3
# Root.__total: 2
r.show()
# self.__value: 3
# Root.__total: 2
Root.show(rr)
# self.__value: 5
# Root.__total: 2
```

## 属性



### 面向对象的支柱

面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是&quot;隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口&quot;。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。

### 练习

#### 练习1：定义一个类描述数字时钟。

参考答案：

```Python
from time import sleep


class Clock(object):
    """数字时钟"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法

        :param hour: 时
        :param minute: 分
        :param second: 秒
        """
        self._hour = hour
        self._minute = minute
        self._second = second

    def run(self):
        """走字"""
        self._second += 1
        if self._second == 60:
            self._second = 0
            self._minute += 1
            if self._minute == 60:
                self._minute = 0
                self._hour += 1
                if self._hour == 24:
                    self._hour = 0

    def show(self):
        """显示时间"""
        return '%02d:%02d:%02d' % \
               (self._hour, self._minute, self._second)


def main():
    clock = Clock(23, 59, 58)
    while True:
        print(clock.show())
        sleep(1)
        clock.run()


if __name__ == '__main__':
    main()
```

#### 练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。

参考答案：

```Python
from math import sqrt


class Point(object):

    def __init__(self, x=0, y=0):
        """初始化方法
        
        :param x: 横坐标
        :param y: 纵坐标
        """
        self.x = x
        self.y = y

    def move_to(self, x, y):
        """移动到指定位置
        
        :param x: 新的横坐标
        "param y: 新的纵坐标
        """
        self.x = x
        self.y = y

    def move_by(self, dx, dy):
        """移动指定的增量
        
        :param dx: 横坐标的增量
        "param dy: 纵坐标的增量
        """
        self.x += dx
        self.y += dy

    def distance_to(self, other):
        """计算与另一个点的距离
        
        :param other: 另一个点
        """
        dx = self.x - other.x
        dy = self.y - other.y
        return sqrt(dx ** 2 + dy ** 2)

    def __str__(self):
        return '(%s, %s)' % (str(self.x), str(self.y))


def main():
    p1 = Point(3, 5)
    p2 = Point()
    print(p1)
    print(p2)
    p2.move_by(-1, 2)
    print(p2)
    print(p1.distance_to(p2))


if __name__ == '__main__':
    main()
```

> **说明：** 本章中的插图来自于Grady Booch等著作的[《面向对象分析与设计》](https://item.jd.com/20476561918.html)一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。