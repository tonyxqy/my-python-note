## 函数和模块的使用

在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。

![$$x_1 + x_2 + x_3 + x_4 = 8$$](./res/formula_3.png)

事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。

![$$C_M^N =\frac{M!}{N!(M-N)!}, \text{(M=7, N=3)} $$](./res/formula_4.png)

可以用Python的程序来计算出这个值，代码如下所示。

```Python
"""
输入M和N计算C(M,N)

Version: 0.1
Author: 骆昊
"""
m = int(input('m = '))
n = int(input('n = '))
fm = 1
for num in range(1, m + 1):
    fm *= num
fn = 1
for num in range(1, n + 1):
    fn *= num
fm_n = 1
for num in range(1, m - n + 1):
    fm_n *= num
print(fm // fn // fm_n)
```

### 函数的作用

不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师*Martin Fowler*先生曾经说过：“**代码有很多种坏味道，重复是最坏的一种！**”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。

### 定义函数

在Python中可以使用`def`关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过`return`关键字来返回一个值，这相当于数学上说的函数的因变量。

在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。

```Python
"""
输入M和N计算C(M,N)

Version: 0.1
Author: 骆昊
"""
def fac(num):
    """求阶乘"""
    result = 1
    for n in range(1, num + 1):
        result *= n
    return result


m = int(input('m = '))
n = int(input('n = '))
# 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数
print(fac(m) // fac(n) // fac(m - n))
```

> **说明：** Python的`math`模块中其实已经有一个名为`factorial`函数实现了阶乘运算，事实上求阶乘并不用自己定义函数。下面的例子中，我们讲的函数在Python标准库已经实现过了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，**实际开发中并不建议做这种低级的重复劳动**。


### 函数的参数

函数是绝大多数编程语言中都支持的一个代码的&quot;构建块&quot;，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持[函数的重载](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD)，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。



#### 位置参数

没有任何说明的参数为位置参数，实参按照顺序以此传递给形参，要求实参和形参的数量和顺序都保持一制。

#### 默认值参数

```python
def 函數名 (...,形参名 = 默认值)：
	函数体
```

调用带有默认值参数的函数时，可以不对默认值参数进行赋值，可以显示赋值来替换其默认值。

```
函数名.__defaults__   #随实查看函数所有默认值参数的当前值。
```

在定义带有默认值参数的函数时，默认值参数必须全部出现在位置参数右侧，任何一个默认值参数的右边都不能再出现位置参数。

```python
def f(a=3,b,c=5):
    print a,b,c
    '''SyntaxError: non-default argument follows default argument'''
```

多次调用函数并不为默认值传递值时，默认值参数只在函数定义时进行解释，然后默认值参数的应用不再发生变化。对于列表，字典这样复杂类型的默认值参数，这一点可能会发生很严重的错误。

```python
def demo (newitem,old_list = []):
    old_list.append(newitem)
    return old_list
print(demo('5',[1,2,3,4]))				#[1, 2, 3, 4, '5']
print(demo('aaa',['a','b']))			#['a', 'b', 'aaa']
print(demo('a'))						#['a']
print(demo('b'))						#['a', 'b']

def demo(newitem,old_list = None):
    if old_list is None:
        old_list=[]
    new_list =old_list[:]
    new_list.append(newitem)
    return new_list
print(demo('5',[1,2,3,4]))				#[1, 2, 3, 4, '5']
print(demo('aaa',['a','b']))			#['a', 'b', 'aaa']
print(demo('a'))						#['a']
print(demo('b'))						#['b']
```

#### 关键值参数

关键参数主要指调用函数时的参数传递方式，与函数定义无关。通过关键参数可以按照参数名字传递值，实参顺序和形参顺序不一致，但不影响参数值的传递结果，避免了用户需要即主参数位置和顺序的麻烦，使得函数的调用和参数的传递更加灵活和方便。

```python
def demo(a,b,c=5):
    print(a,b,c)
demo(3,7)					#3 7 5
demo(c=8,a=9,b=0)			#9 0 8
```

原示例



```Python
from random import randint


def roll_dice(n=2):
    """摇色子"""
    total = 0
    for _ in range(n):
        total += randint(1, 6)
    return total


def add(a=0, b=0, c=0):
    """三个数相加"""
    return a + b + c


# 如果没有指定参数那么使用默认值摇两颗色子
print(roll_dice())						
# 摇三颗色子
print(roll_dice(3))
print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
# 传递参数时可以不按照设定的顺序进行传递
print(add(c=50, a=100, b=200))
```

我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用`add`函数，这跟其他很多语言中函数重载的效果是一致的。

#### 可变长数组

两种形式：*parameter和**parameter，前者用来接收任意多个位置实参并将其存放在一个元组中，后者接收多个关键参数并将其收入字典中

```python
def demo(*p):
    print(p)
demo(1,2,3)						#(1, 2, 3)
def demo(**p):
    for item in p.items():
        print(item)
demo(x=1,y=2,z=3)				#('x', 1)
								#('y', 2)
								#('z', 3)
```

其实上面的`add`函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。

```Python
# 在参数名前面的*表示args是一个可变参数
def add(*args):
    total = 0
    for val in args:
        total += val
    return total


# 在调用add函数时可以传入0个或多个参数
print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
print(add(1, 3, 5, 7, 9))
```

#### 参数传递时的序列解包

为含有多个形参的函数传递参数时，可以使用列表，元组，集合，字典以及其他可迭代对象作为实参，并在实参名称前面加一个*，python解释器将为其进行自动解包，然后传递给多个位置形参。如果使用字典对象为参数，则默认使用字典的“键“；如果需要将字典的”值”作为参数则需要使用字典的value方法.定义字典进行序列解包则需要用**，键作为关键字，

```python
def demo(a,b,c):
    print(a+b+c)
seq = [1,2,3]
demo(*seq)          #6
tup = (1,2,3)
demo(*tup)          #6
demo(**{'a':97,'b':98,'c':99})   #294
```



### 用模块管理函数

对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。

```Python
def foo():
    print('hello, world!')


def foo():
    print('goodbye, world!')


# 下面的代码会输出什么呢？
foo()
```

当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为`foo`的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过`import`关键字导入指定的模块就可以区分到底要使用的是哪个模块中的`foo`函数，代码如下所示。

`module1.py`

```Python
def foo():
    print('hello, world!')
```

`module2.py`

```Python
def foo():
    print('goodbye, world!')
```

`test.py`

```Python
from module1 import foo

# 输出hello, world!
foo()

from module2 import foo

# 输出goodbye, world!
foo()
```

也可以按照如下所示的方式来区分到底要使用哪一个`foo`函数。

`test.py`

```Python
import module1 as m1
import module2 as m2

m1.foo()
m2.foo()
```

但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个`foo`，因为后导入的foo覆盖了之前导入的`foo`。

`test.py`

```Python
from module1 import foo
from module2 import foo

# 输出goodbye, world!
foo()
```

`test.py`

```Python
from module2 import foo
from module1 import foo

# 输出hello, world!
foo()
```

需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是&quot;\_\_main\_\_&quot;。

`module3.py`

```Python
def foo():
    pass


def bar():
    pass


# __name__是Python中一个隐含的变量它代表了模块的名字
# 只有被Python解释器直接执行的模块的名字才是__main__
if __name__ == '__main__':
    print('call foo()')
    foo()
    print('call bar()')
    bar()
```

`test.py`

```Python
import module3

# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__
```



### 文档字符串(doc,str)

在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明

当我们编写了文档字符串时，就可以通过help（）函数来查看函数的说明

文档字符串非常简单，在函数的第一行写的就是文档字符串

```python
def fn(a:int,b:bool,c:str='hello')->int:
    '''
    这是一个文档字符串示例
    函数的作用：……
    函数的参数：
    	a：作用，类型，默认值……
    	b: 作用，类型，默认值……
    	c: 作用，类型，默认值……
    '''
    return
```

### 作用域与命名空间

作用域指的是变量生效的区域

python中一共有两种作用域全局作用域和局部作用域

- **全局作用域**
  - 全局作用域在程序执行时创建，在程序执行结束时销毁
  - 在函数以外的区域全是全局作用域
  - 在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问

- **函数作用域**
  - 函数作用域在函数调用时创建，在调用结束时销毁
  - 函数每调用依次就会产生一个新的函数作用域
  - 函数作用域中定义的变量都是局部变量，它只能在函数内部被访问

- **变量的查找**
  - 当我们使用变量时，会优先在当前作用域中寻找变量
  - 如果没有则继续区上一级作用域中寻找
  - 如果依然没有则继续去上一级作用域中，依次类推
  - 如果直到查到全局作用域依然没有找到则会抛出异常

- **命名空间（namespace）**
  - 命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间当中
  - 每一个作用域都会有一个它对应的命名空间
  - 全局命名空间，用来保存全局变量。函数命名空间用来保存函数中的变量
  - 命名空间实际上就是一个字典，是一个专门用来存储变量的字典
  - locals()用来获取当前作用域的命名空间



### 递归

 递归是解决问题的一种方式，它和循环很像

 它的整体思想是，将一个大问题分解为一个个的小问题，直到问题无法分解时，再去解决问题

 递归式函数的两个要件

- 1.基线条件
  - 问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了

- 2.递归条件
  - 将问题继续分解的条件
  - 递归和循环类似，基本是可以互相代替的，
  - 循环编写起来比较容易，阅读起来稍难
  - 递归编写起来难，但是方便阅读

### 函数式编程

在python中，函数是一等对象。一等对象具有以下特点：

- 对象在运行时创建
- 能赋值给变量或作为数据结构中的元素
- 能作为参数传递

 高阶函数

-  接收函数作为参数，或者将函数作为返回值的函数是高阶函数

-  当我们使用一个函数作为参数时，实际上是将指定的代码传递进了目标函数

```python
# 创建一个列表
l = [1,2,3,4,5,6,7,8,9,10]

# 定义一个函数
#   可以将指定列表中的所有的偶数，保存到一个新的列表中返回

# 定义一个函数，用来检查一个任意的数字是否是偶数
def fn2(i) :
    if i % 2 == 0 :
        return True

    return False    

# 这个函数用来检查指定的数字是否大于5
def fn3(i):
    if i > 5 :
        return True    
    return False

def fn(func , lst) :

    '''
        fn()函数可以将指定列表中的所有偶数获取出来，并保存到一个新列表中返回

        参数：
            lst：要进行筛选的列表
    '''
    # 创建一个新列表
    new_list = []

    # 对列表进行筛选
    for n in lst :
        # 判断n的奇偶
        if func(n) :
            new_list.append(n)
        # if n > 5 :
        #     new_list.append(n)

    # 返回新列表
    return new_list
```

### 闭包

将函数作为返回值返回，也是一种高阶函数

```python
def fn():
    #函数内部再定义一个函数
    def inner():
        print('我是fn2')

    #将内部函数inner作为返回值返回
    return inner
r=fn()
r()
#r是一个函数，是调用fn()后返回的函数
#这个函数是再fn（）内定义的，并不是全局函数
#所以这个函数总是能访问fn（）函数内的变量
```

### 

```python

```



### lambda表达式

lambda用来声明匿名函数，即没有函数名字的临时使用的小函数。lambda只可以包含一个表达式，支持默认值参数和关键参数，表达式的计算结果就是函数返回值

语法：lambda 参数列表： 返回值

```python
f = lambda x,y,z:x+y+z
print(f(1,2,3))                                          #6
g = lambda x,y=2,z=3:x+y+z   #含有默认值参数
print(g(1))                                              #6
print(g(2,z=4,y=5))                                      #11
L = [(lambda x:x**2),(lambda x:x**3),(lambda x:x**4)]
print(L[0](2),L[1](2),L[2](2))                           #4  8  16
D = {'f1':(lambda:2+3),'f2':(lambda:2*3),'f3':(lambda:2**3)}
print(D['f1'](),D['f2'](),D['f3']())                     #5  6  8
L = [1,2,3,4,5]
'''map()函数会根据提供的函数对指定序列做映射'''
print(list(map((lambda x:x+10),L)))                      #[11,12,13,14,15]
def demo(n):
    return n*n
print(demo(5))                                           #25
print(list(map(lambda x:demo(x),L)))                     #[1, 4, 9, 16, 25]
data = list(range(20))
import random
'''shuffle函数随机排序'''
random.shuffle(data)
print(data)                                              #[15, 7, 0, 3, 16, 10, 1, 12, 14, 13, 6, 2, 18, 17, 4, 11, 19, 8, 5, 9]
data.sort(key = lambda x:x)
print(data)                                              #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
data.sort(key = lambda x:len(str(x)))       
print(data)                                              #同上
data.sort(key = lambda x:len(str(x)),reverse = True)
print(data)                                              #[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
```

注意

```python
r = []
for x in range(10):
    r.append(lambda:x**2)
print(r[0]())                   #81
print(r[1]())                   #81

r=[]
for x in range(10):
    r.append(lambda n=x:n**2)
print(r[0]())                   #0
print(r[1]())                   #1
```





### 练习

#### 练习1：实现计算求最大公约数和最小公倍数的函数。

参考答案：

```Python
def gcd(x, y):
    """求最大公约数"""
    (x, y) = (y, x) if x > y else (x, y)
    for factor in range(x, 0, -1):
        if x % factor == 0 and y % factor == 0:
            return factor


def lcm(x, y):
    """求最小公倍数"""
    return x * y // gcd(x, y)
```

#### 练习2：实现判断一个数是不是回文数的函数。

参考答案：

```Python
def is_palindrome(num):
    """判断一个数是不是回文数"""
    temp = num
    total = 0
    while temp > 0:
        total = total * 10 + temp % 10
        temp //= 10
    return total == num
```

#### 练习3：实现判断一个数是不是素数的函数。

参考答案：

```Python
def is_prime(num):
    """判断一个数是不是素数"""
    for factor in range(2, int(num ** 0.5) + 1):
        if num % factor == 0:
            return False
    return True if num != 1 else False
```

#### 练习4：写一个程序判断输入的正整数是不是回文素数。

参考答案：

```Python
if __name__ == '__main__':
    num = int(input('请输入正整数: '))
    if is_palindrome(num) and is_prime(num):
        print('%d是回文素数' % num)
```

> **注意**：通过上面的程序可以看出，当我们**将代码中重复出现的和相对独立的功能抽取成函数**后，我们可以**组合使用这些函数**来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。

#### 练习5：编写函数计算园的面积

```python
from math import pi as PI
def CircleArea(r):
    if(isinstance(r,int) or isinstance(r,float)):
        return PI*r*r
    else:
        return('You must give me an integer or float as radius.')
 print(CircleArea(3))
```

#### 练习6:编写函数，接收任意多个实数，返回一个元组，其中第一个元素为所有参数的平均值，其他元素为所有参数中大于平均值的实数

```python
def demo(*para):
    avg = sum(para)/len(para)
    g = [i for i in para if i>avg]
    return (avg,)+tuple(g)

print(demo(1,2,3,4))
```

#### 练习7：编写函数，接收字符串参数，返回一个元组，其中第一个元素为大写字母个数，第二个为小写字母个数

```python
def demo(s):
    result = [0,0]
    for ch in s:
        if 'a' <= ch <= 'z':
            result[1] += 1
        elif 'A' <= ch <= 'Z':
            result[0] += 1
    return result

print(demo('aaaabbbbC'))
```

#### 练习8：编写函数，接收包含20个整数的列表lst和一个整数k作为参数，返回新列表，处理规则为：将列表lst中下标k之前的元素逆序，下标k之后的元素逆序，然后将整个列表lst中所有元素逆序。

```python
def demo(lst,k):
    x=lst[:k-1]
    x.reverse()
    y=lst[k:]
    y.reverse()
    r=x
    r.append(k)
    r.extend(y)
    r.reverse()
    return r
lst = list(range(1,21))
print(lst)
print(demo(lst,5))
```

#### 练习9：编写函数，接收整数参数t，返回斐波那契数列中大于t的第一个数

```python
def demo(t):
    a,b=1,1
    while b<t:
        a,b=b,a+b
    else:
        return b
print(demo(50))				#55
```

#### 练习10：编写函数，接收一个整数t为参数，打印杨辉三角的前t行

```python
def demo(t):
    print([1])
    print([1,1])
    line = [1,1]
    for i in range(2,t):
        r = []
        for j in range(0,len(line)-1):
            r.append(line[j]+line[j+1])
        line =[1]+r+[1]
        print(line)
demo(10)
```

#### 练习11：编写函数，接收一个正偶数为参数，输出两个素数，并且这两个素数之和等于原来的正偶数。如果存在多组符合条件的素数，则全部输出。

```python
import math
def is_prime(n):
    m = int(math.sqrt(n))+1
    for i in range(2,m):
        if n%i == 0:
            return False
    return True

def demo(n):
    if isinstance(n,int) and n>0 and n%2 == 0:
        for i in range(3,int(n/2)+1):
            if i%2 ==1 and is_prime(i) and is_prime(n-i):
                print(i,'+',n-i,'=',n)
demo(60)
```

#### 练习12：编写函数，接收两个正整数作为参数，返回一个数组，其中得以个元素为最大公约数，第二个元素为最小公倍数

```python
def demo(m,n):
    if m>n:
        m,n =n,m
    for i in range(m,0,-1):
        if m % i == 0 and n % i ==0:
            p=i
            print(p)
            break
    return(m*n//p,p)
print(demo(20,30))
'''辗转相除法'''
def demo1(m,n):
    (m,n)= (n,m) if m>n else (m,n)
    p = m*n
    while m!=0:
        r = n%m
        print('%d = %d %% %d'%(r,n,m))
        n = m
        print('%d = %d '%(n,m))
        m = r
        print('%d = %d '%(m,n))
        print()
    return(int(p/n),n)
print(demo1(20,30))
r = n % m
10 = 30 % 20
n = 20
m = 10

r = n % m
0 = 20 % 10
n = 10
m = 0
假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：
1997 / 615 = 3 (余 152)
615 / 152 = 4(余7)
152 / 7 = 21(余5)
7 / 5 = 1 (余2)
5 / 2 = 2 (余1)
2 / 1 = 2 (余0)
至此，最大公约数为1
```

#### 练习13：编写函数接收一个所有元素值互不相等的整数列表x和一个整数n，要求将值为n的元素作为支点，将列表中所有值小于n的元素全部放到n的前面，所有值大于n的元素放到n的元素放到n的后面。

```python
import random
def demo(x,n):
    if n not in x:
        print(n,'is not an element of',x)
        return
    i = x.index(n)
    x[0],x[i] = x[i],x[0]
    key = x[0]
    i = 0
    j = len(x)-1
    while i<j:
        while i<j and x[j]>=key:
            j -=1
        x[i] = x[j]
        while i<j and x[i]<=key:
            i +=1
        x[j]=x[i]
        x[i]=key
x=list(range(1,10))
random.shuffle(x)
print(x)
demo(x,4)
print(x)
```

##### 练习14：编写函数，计算字符串匹配的准确率

以打字练习程序为例，假设origin为原始内容，userInput为用户输入内容。

```python
def Rate(origin,userInput):
    if not(isinstance(origin,str) and isinstance(userInput,str)):
        print('The two parameters must be string.')
        return
    if len(origin)<len(userInput):
        print('Sorry.I suppose the second parameter string is shorter.')
        return
    right = 0
    for origin_char,user_char in zip(origin,userInput):
        if origin_char==user_char:
            right += 1
    return right/len(origin)
```



### 变量的作用域

最后，我们来讨论一下Python中有关变量作用域的问题。

```Python
def foo():
    b = 'hello'

    # Python中可以在函数内部再定义函数
    def bar():
        c = True
        print(a)
        print(b)
        print(c)

    bar()
    # print(c)  # NameError: name 'c' is not defined


if __name__ == '__main__':
    a = 100
    # print(b)  # NameError: name 'b' is not defined
    foo()
```

上面的代码能够顺利的执行并且打印出100、hello和True，但我们注意到了，在`bar`函数的内部并没有定义`a`和`b`两个变量，那么`a`和`b`是从哪里来的。我们在上面代码的`if`分支中定义了一个变量`a`，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的`foo`函数中我们定义了变量`b`，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在`foo`函数的外部并不能访问到它；但对于`foo`函数内部的`bar`函数来说，变量`b`属于嵌套作用域，在`bar`函数中我们是可以访问到它的。`bar`函数中的变量`c`属于局部作用域，在`bar`函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的`input`、`print`、`int`等都属于内置作用域。

再看看下面这段代码，我们希望通过函数调用修改全局变量`a`的值，但实际上下面的代码是做不到的。

```Python
def foo():
    a = 200
    print(a)  # 200


if __name__ == '__main__':
    a = 100
    foo()
    print(a)  # 100
```

在调用`foo`函数后，我们发现`a`的值仍然是100，这是因为当我们在函数`foo`中写`a = 200`的时候，是重新定义了一个名字为`a`的局部变量，它跟全局作用域的`a`并不是同一个变量，因为局部作用域中有了自己的变量`a`，因此`foo`函数不再搜索全局作用域中的`a`。如果我们希望在`foo`函数中修改全局作用域中的`a`，代码如下所示。

```Python
def foo():
    global a
    a = 200
    print(a)  # 200


if __name__ == '__main__':
    a = 100
    foo()
    print(a)  # 200
```

我们可以使用`global`关键字来指示`foo`函数中的变量`a`来自于全局作用域，如果全局作用域中没有`a`，那么下面一行的代码就会定义变量`a`并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用`nonlocal`关键字来指示变量来自于嵌套作用域，请大家自行试验。

在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被[垃圾回收](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对[迪米特法则](https://zh.wikipedia.org/zh-hans/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B)的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))，这个我们在后续的内容中进行讲解。

> **说明：** 很多人经常会将“闭包”和[“匿名函数”](https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0)混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看[维基百科](https://zh.wikipedia.org/wiki/)的解释或者[知乎](https://www.zhihu.com/)上对这个概念的讨论。

说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。

```Python
def main():
    # Todo: Add your code here
    pass


if __name__ == '__main__':
    main()
```

#### 变量作用域

​	分两种情况

- 一个变量已经在函数外定义，如果需要在函数内修改这个变量得值，并将这个值反映到函数外，可以在函数内用global声明这个变量为全局变量。

- 在函数内直接用global声明为全局变量，即使在函数外没用定义该全局变量，在调用这个函数之后，将自动增加新得全局变量

  在函数内如果值引用某个你变量得值而没有为其赋新的值，该变量为隐式得全局变量，如果在函数内任意位置有为变量赋新值得操作，该变量将被认为是隐式得局部变量，除非在函数内显示得用关键词进行声明

```python
def demo():
    global x
    x=3
    y=4
    print(x,y)
x=5
demo()              #3  4
print(y)          #NameError: name 'y' is not defined
```

如果局部变量和全局变量具有相同得名字则该局部变量会在自己的作用域内隐藏同名的全局变量

```python
def demo():
    x=3
    print(x)
x=5
demo()
```

## 高级话题

##### 内置函数map（）

可以将一个一个单参数函数依次作用到一个序列或迭代器对象的每个元素上，并返回一个map对象作为结果，其中每一个元素是原序列中元素经过该函数处理后的结果，该函数不对原序列或迭代器对象做任何修改。

- map()函数可以对可迭代对象中的所有元素进行指定操作

```python
print(list(map(str,range(5))))			
print(list(map(lambda x:x+5,range(10))))

l = [1,2,3,4,5,6,7,8,9,10]
print(list(map(lambda i:i+1,l)))
# [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

##### 内置函数reduce（）

可以将一个接收两个参数的函数以累积的方式从左到右依次作用到一个序列或迭代器对象的所有元素上。

```python
from functools import reduce
seq = [1,2,3,4,5,6,7,8,9]
print(reduce(lambda x,y:x+y,seq)) #45  
def add(x,y):
    return x+y
print(reduce(add,range(10)))	  #45
```

##### 内置函数filter（）

- filter()
  - filter()可以从序列中过滤处符合条件的元素保存到一个新的序列中
  - 参数：
    - 1.函数，根据该函数来过滤序列（可迭代）
    - 2.需要过滤的序列（可迭代）
  - 返回值
    - 过滤后的新序列

```python
l = [1,2,3,4,5,6,7,8,9,10]
def fn2(i) :
    if i % 2 == 0 :
        return True

    return False   
print(list(filter(fn2,l)))	#[2, 4, 6, 8, 10]
#注意传递的是函数对象不用加括号，而fn2实际上就只有一个作用，就是作为filter()的参数
#匿名函数lambda函数表达式
print(list(filter(lambda i:i%2==0,l)))
```

### 

将一个函数作用到一个序列上，返回序列中使得该函数返回值为True的那些元素组成的列表，元组或者字符串

```python
seq=['foo','x41','?!','***']
def func(x):
    return x.isalnum()
print(list(filter(func,seq)))    #['foo', 'x41']
x=[x for x in seq if x.isalnum()]
print(x)						 #['foo', 'x41']
```

##### 内置函数yield（）

迭代器最大的作用是惰性求值，尤其适用于大数据处理。

```python
def f():
    a,b=1,1
    while True:
        yield a
        a,b=b,a+b
a = f()
for i in range(10):
    print(a.__next__(),end=' ')
```

##### 内置函数sort（）

该方法用来对列表元素进行排序

sort（）方法默认是直接比较列表元素的大小

sort（）可以接收一个关键字参数，key

- key需要一个函数作为参数，当设置了函数作为参数
- 每次都会以列表中的一个元素作为参数来调用函数，并使函数返回

```python
l = ['bb','aaaa','ddddddddd','c','fffffff']
l.sort()
print(l)#['aaaa', 'bb', 'c', 'ddddddddd', 'fffffff']
l.sort(key = len)
print(l)#['c', 'bb', 'aaaa', 'fffffff', 'ddddddddd']
l = [2.5,'1',3,'6',4]
l.sort(key = int)
print(l)#['1', 2.5, 3, 4, '6']
```

sorted（）

这个函数和sort（）的用法基本一致，但是sorted（）可以对任意的序列进行排序

并且使用sorted（）排序不会影响原来的对象，而是返回一个对象

### 装饰器

如果我们希望可以再函数开始前打印开始函数，函数结束时打印函数结束

我们可以通过修改函数中的代码来完成这个要求，但是会产生以下一下问题

- 如果修改的函数过多，修改起来会比较麻烦
- 不方便后期维护
- 会违反开闭原则（ocp）
  - 程序的设计，要求开发对程序的拓展，要关闭对程序的修改

在不修改原函数的情况下对函数进行拓展

```python
def mul(a,b):
    return a*b

def begin_end(old):
    '''
    用来对其他函数进行拓展，使其他函数可以在执行前打印开始执行，执行后打印执行结束
    '''
    def new_function(*args,**kwargs):
        print('开始执行')
        #调用被扩展函数
        result = old(*args,**kwargs)
        print('执行结束')
        #返回函数执行结果
        return result
    return new_function

f = begin_end(mul)
print(f(1,2))
```

在开发过程当中一般通过装饰器来修改函数

```python
@begin_end
def say_hello():
    print('hello~~~')
#开始执行
#hello~~~
#执行结束
def fn3(old):
    '''
    用来对其他函数进行拓展，使其他函数可以在执行前打印开始执行，执行后打印执行结束
    '''
    def new_function(*args,**kwargs):
        print('fn3开始执行')
        #调用被扩展函数
        result = old(*args,**kwargs)
        print('fn3执行结束')
        return result
    return new_function
#可以为同一个函数指定多个装饰器，这样函数会从内到外调用装饰器
@begin_end
@fn3
def say_hello():
    print('hello~~~')

say_hello()


#开始执行
#fn3开始执行
#hello~~~
#fn3执行结束
#执行结束
```

