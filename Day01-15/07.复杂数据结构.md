### 使用列表

不知道大家是否注意到，刚才我们讲到的字符串类型（`str`）和之前我们讲到的数值类型（`int`和`float`）有一些区别。数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法。接下来我们要介绍的列表（`list`），也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在`[]`中，多个元素用`,`进行分隔，可以使用`for`循环对列表元素进行遍历，也可以使用`[]`或`[:]`运算符取出列表中的一个或多个元素。

#### 列表对象常用方法

| 方法                   |                                                            |
| ---------------------- | ---------------------------------------------------------- |
| `list.append(x)`       | 将元素x添加到列表的尾部                                    |
| `list.extend(L)`       | 将一个可迭代序列中所有的元素添加到列表尾部                 |
| `list.insert(index,x)` | 在列表指定位置index处添加元素x                             |
| `list.remove(x)`       | 在列表中删除首次出现的指定元素                             |
| `list.pop([index])`    | 删除并返回列表对象指定位置的元素，默认为最后一个元素       |
| `list.clear()`         | 删除列表中所有元素，但保留列表对象                         |
| `list.index(x)`        | 返回第一个值位x的元素下标，若不存在值位x的元素，则抛出异常 |
| `list.count(x)`        | 返回指定元素x在列表中出现的次数                            |
| `list.reverse()`       | 对列表进行原地翻转                                         |
| `list.sort()`          | 对列表进行原地排序                                         |
| `list.copy()`          | 对列表进行浅复制                                           |

下面的代码演示了如何定义列表、如何遍历列表以及列表的下标运算。

```python
list1 = [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 = ['hello'] * 3print(list2) # ['hello', 'hello', 'hello']# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5])  # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] = 300print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)):    print(list1[index])# 通过for循环遍历列表元素for elem in list1:    print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1):    print(index, elem)
```

下面的代码演示了如何向列表中添加元素以及如何从列表中移除元素。

```python
list1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400)# 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1:    list1.remove(3)if 1234 in list1:    list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # []'''循环加remove（）方法删除列表中指定元素的重复会发生错误''''''列表具有自动管理内存的功能在删除列表元素时该元素后面的所有元素的索引就会发生改变'''x = list(range(20))print(x)#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]for i in range(len(x)):    del x[0]print(x)# []'''删除相同的元素''''''错误样例'''x = [1,2,1,2,1,1,1]for i in x:    if i == 1:        x.remove(i)#[2,2,1]'''正确示例'''x = [1,2,1,2,1,1,1]for i in x[::]:    if i == 1:        x.remove(i)
```

#### 列表切片

和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。我们可以使用切片操作实现很多目的，例如原地修改列表内容，列表元素增删改查，以及元素替换等操作都可以通过切片来实现，并且不影响列表对象的内存地址。

```python
fruits = ['grape', 'apple', 'strawberry', 'waxberry']fruits += ['pitaya', 'pear', 'mango']# 列表切片fruits2 = fruits[1:4]print(fruits2) # apple strawberry waxberry# 可以通过完整切片操作来复制列表fruits3 = fruits[:]print(fruits3) # ['grape', 'apple', 'strawberry', 'waxberry', 'pitaya', 'pear', 'mango']fruits4 = fruits[-3:-1]print(fruits4) # ['pitaya', 'pear']# 可以通过反向切片操作来获得倒转后的列表的拷贝fruits5 = fruits[::-1]print(fruits5) # ['mango', 'pear', 'pitaya', 'waxberry', 'strawberry', 'apple', 'grape']'''切片越界了也不会报错'''print(fruits[100:]) #[]'''列表元素的增加'''aList = [3,5,7]aList[len(aList):] = [9]print(aList)            #[3, 5, 7, 9]'''列表元素的修改'''aList[:3]=[1,2,3]print(aList)            #[1, 2, 3, 9]aList = list(range(10))aList[::2] = [0] *(len(aList)//2)print(aList)         #[0, 1, 0, 3, 0, 5, 0, 7, 0, 9]'''列表元素的删除'''aList[:3] = []print(aList)            #[]'''结合del命令与切片操作来删除列表中的部分元素'''aList = [3,5,7,9,11]del aList[:3]print(aList)            #[9, 11]
```

下面的代码实现了对列表的排序操作。

```python
list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']list2 = sorted(list1)# sorted函数返回列表排序后的拷贝不会修改传入的列表# 函数的设计就应该像sorted函数一样尽可能不产生副作用list3 = sorted(list1, reverse=True)# 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序list4 = sorted(list1, key=len)print(list1)print(list2)print(list3)print(list4)# 给列表对象发出排序消息直接在列表对象上进行排序list1.sort(reverse=True)print(list1)
```

#### 列表基于值得内存管理和深浅复制

由于python时基于字典的自动内存管理方式，但为对象修改值时，并不是真的直接修改变量得值，而是使变量指向新的值。

```python
a = [1,2,3]print(id(a))                #2735224872512b = [1,2]print(id(b))                #2735224877504print(id(a)==id(b))         #Falseprint(id(a[0])==id(b[0]))    #True'''append(),extend(),insert()等函数原地操作'''print(id(a))                #1742489148864a.append(4)print(id(a))                #1742489148864'''乘法来拓展列表对象是生成新的列表'''aList=[3,5,7]print(id(aList))            #2774797737344aList = aList*3print(id(aList))            #2774797744320'''创建新列表''''''用*对现有列表进行重复创建列表时，并不创建元素的复制，而是创建已有对象的引用。当修改其中一个值时，相应的引用也会被修改。'''x = [[None]*2]*3print(x)            #[[None, None], [None, None], [None, None]]x[0][0]=5print(x)            #[[5, None], [5, None], [5, None]]
```

列表元素增加时可以使用`+运算符，append()`等方法+运算符是创建了一个新列表。

切片浅拷贝，赋值深拷贝

```python
'''赋值运算'''aList = [3,5,7]bList = aList       #bList与aList指向同一块内存print(id(aList))    #1676016573888print(id(bList))    #1676016573888bList[1] = 8print(aList)        #[3, 8, 7]可见深赋值改动bList的同时改了aListprint(aList==bList)     #Trueprint(aList is bList)   #True'''切片'''aList = [3,5,7]bList = aList[::]       #浅拷贝print(aList is bList)   #FalsebList[1] = 8print(aList)            #[3, 5, 7]可见是浅赋值没有改变aList
```

#### 用于序列操作的常用内置函数

- `max(列表)，min(列表)`返回列表中的最大或者最小元素。对字典进行操作时，默认是对字典的就“键”进行计算，如果需要对字典“值”进行计算，则需要使用字典对象的`value（）`方法明确说明。

```python
a = {1:1,2:5,3:8}print(max(a))           #3print(max(a.values()))   #8
```

- `sum(列表)`对数值型列表的元素进行求和运算，对非数值型列表运算则出错，同样适用于数值型元组，集合，range对象，字典等等。

```
a = {1:1,2:5,3:8}print(sum(a))               #6print(sum(a.values()))      #14
```

- `zip(列表1，列表2，……)`将多个列表或元组对应位置的元素组合为元组

```
aList = [1,2,3]bList = [4,5,6]cList = [7,8,9]dList = zip(aList,bList,cList)print(list(dList))          #[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```

- `enumerate(列表)`美剧列表，元组，或其他可迭代对象的元素，返回枚举对象，枚举对象中每个元素是包含下表和元素值得元组。

```python
cList = [7,8,9]for item in enumerate(cList):    print(item,end=' ')             #(0, 7) (1, 8) (2, 9)     for index,ch in enumerate('SDIBT'):    print((index,ch),end=',')       #(0, 'S'),(1, 'D'),(2, 'I'),(3, 'B'),(4, 'T'),
```

### 生成式和生成器

我们还可以使用列表的生成式语法来创建列表，代码如下所示。

```
f = [x for x in range(1, 10)]print(f)                    #[1, 2, 3, 4, 5, 6, 7, 8, 9]f = [x + y for x in 'ABCDE' for y in '1234567']print(f)'''['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7']'''# 用列表的生成表达式语法创建列表容器# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间f = [x ** 2 for x in range(1, 1000)]print(sys.getsizeof(f))  # 查看对象占用内存的字节数print(f)# 请注意下面的代码创建的不是一个列表而是一个生成器对象# 通过生成器可以获取到数据但它不占用额外的空间存储数据# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)f = (x ** 2 for x in range(1, 1000))print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间print(f)for val in f:    print(val)    freshfruit = ['  banana',' loganberry ','passion fruit ']aList = [w.strip() for w in freshfruit]print(aList)                #['banana', 'loganberry', 'passion fruit']for i,v in enumerate(freshfruit):    freshfruit[i]=v.strip()print(freshfruit)freshfruit = list(map(str.strip,freshfruit))print(freshfruit)'''使用列表推导式实现嵌套列表得平铺'''vec = [[1,2,3],[4,5,6],[7,8,9]]aList = [num for elem in vec for num in elem]print(aList)        #[1, 2, 3, 4, 5, 6, 7, 8, 9]'''过滤不符合条件得元素'''aList = [-1,-4,6,7.5,-2.3,9,-11]bList = [i for i in aList if i>0]print(bList)        #[6, 7.5, 9]scores = {"Zhang San":45,"Li Si":78,"Wang Wu":40,"Zhou Liu":96,"Zhao Qi":65,"Sun Ba":90,"Zheng Jiu":78,"Wu Shi":99,"Dong Shiyi":60}highest = max(scores.values())print(highest)                  #99lowest = min(scores.values())print(lowest)                   #40average = sum(scores.values())/len(scores)print(average)                  #72.333333333333330highestPerson = [name for name , score in scores.items() if score == highest]print(highestPerson)            #['Wu Shi']
```

### yield语法详细解析

首先可以把yield看作“return”，普通得return就是在程序中返回某个值，返回之后程序就不再往下运行下去了。看作return之后再把它看作是一个生成器（generator）的一部分（带yield的函数才是真正的迭代器）。

```
def foo():    print("starting....")    while True:        res = yield 4        print("res",res)g = foo()print(next(g))print('*'*20)print(next(g))
```

结果

```
starting....                 #第一个时while上面的print结果4                           #第二个是return出的结果,是执行print（next(g)）的结果********************res None4
```



接下来解释代码运行顺序：

- 程序开始以后，因为`foo`函数中有`yield`关键字，所以`foo`函数不会真的执行，而是先得到一个生成器g（相当于一个对象）
- 直到调用`next`方法，`foo`函数正式执行，先执行`foo`函数中的`print()`方法，然后进入`while`循环
- 程序遇到yield关键字，然后把yield想象成return，return了一个4之后，程序停止，**并没有把执行结果赋值给res操作**，此时`next（g）`语句执行完成，所以输出的前两行（第一个时while上面的print结果，第二个是return出的结果）是执行`print（next(g)）`的结果
- 程序执行`print("*"*20)`,输出20个*
- 又开始执行下面的`print(next(g))`，这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个**next程序停止的地方开始执行的**，**也就是要执行res的赋值操作**，这时候要注意，这时候赋值操作右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值时None，所以接着下面的输出是res None
- 程序会继续再while里执行，又一次碰到yield，这时候同样return出4，然后程序停止





除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过`yield`关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成[斐波拉切数列](https://zh.wikipedia.org/wiki/斐波那契数列)的生成器。所谓斐波拉切数列可以通过下面[递归](https://zh.wikipedia.org/wiki/递归)的方法来进行定义：

![img](file://C:/Users/tony5/Desktop/python/Python-100-Days/Day01-15/res/formula_6.png?lastModify=1620107890)

![img](file://C:/Users/tony5/Desktop/python/Python-100-Days/Day01-15/res/formula_7.png?lastModify=1620107890)

![img](file://C:/Users/tony5/Desktop/python/Python-100-Days/Day01-15/res/formula_8.png?lastModify=1620107890)

![img](file://C:/Users/tony5/Desktop/python/Python-100-Days/Day01-15/res/fibonacci-blocks.png?lastModify=1620107890)

```
def fib(n):    a, b = 0, 1    for _ in range(n):        a, b = b, a + b        yield adef main():    for val in fib(20):        print(val)if __name__ == '__main__':    main()
```

### 使用元组

Python中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。

元组没有提供`append(),extend(),insert()`无法想元组中添加元素，同样，元组没有`remove（）和pop（）`方法，也不支持对元组元素进行`del`操作，不能从元素中删除元素，只能使用`del`命令删除整个元组。元组也支持切片操作，但是只能通过切片来访问元组中的元素，而不支持使用切片来修改元组中元素的值，也不支持使用切片操作来为元组增加或删除元素

```
# 定义元组t = ('骆昊', 38, True, '四川成都')print(t)#创建元组'''如果元组中只包含一个元素，需要在元素后面加上一个逗号'''a_tuple('a',)# 获取元组中的元素print(t[0])print(t[3])# 遍历元组中的值for member in t:    print(member)# 重新给元组赋值# t[0] = '王大锤'  # TypeError# 变量t重新引用了新的元组原来的元组将被垃圾回收t = ('王大锤', 20, True, '云南昆明')print(t)# 将元组转换成列表person = list(t)print(person)# 列表是可以修改它的元素的person[0] = '李小龙'person[1] = 25print(person)# 将列表转换成元组fruits_list = ['apple', 'banana', 'orange']fruits_tuple = tuple(fruits_list)print(fruits_tuple)#将元组转换为列表print(tuple('abcdefg'))     #('a', 'b', 'c', 'd', 'e', 'f', 'g')
```

元组属于不可变序列,其元素是不可以变的，但是如果元组中包含可变序列情况就会略有不同

```
x = ([1,2],3)x[0][0] = 5print(x)        #([5, 2], 3)
```

这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？

1. 元组中的元素是无法修改的，事实上我们在项目中尤其是[多线程](https://zh.wikipedia.org/zh-hans/多线程)环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。
2. 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。

![img](file://C:/Users/tony5/Desktop/python/Python-100-Days/Day01-15/res/ipython-timeit.png?lastModify=1620107890)

#### 序列解包

使用序列解包功能可以对多个变量同时进行赋值：

```
x,y,z = 1,2,3print(x,y,z)                #1 2 3v_tuple = (False,3.5,'exp')(x,y,z) = v_tupleprint(x,y,z)                #False 3.5 exp'''序列解包对于字典操作'''#默认是对字典的"键"操作s = {'a':1,'b':2,'c':3}b,c,d = sprint(b)                    #as = {'a':1,'b':2,'c':3}b,c,d = s.items()print(b)                    #('a', 1)s = {'a':1,'b':2,'c':3}b,c,d = s.values()print(b,c,d)                #1 2 3'''使用序列解包可以很方便得遍历多个序列'''keys = ['a','b','c','d']values = [1,2,3,4]for k ,v in zip(keys,values):    print(k,v,end=' ')      #a 1 b 2 c 3 d 4
```

#### *号化进行序列解包（py3.5）

```
print(*[1],*[2],3,*[4,5])       #1 2 3 4 5def demo(a,b,c,d):    print(a,b,c,d)demo(**{'a':1,'c':3},**{'b':2,'d':4})#1 2 3 4demo(*{'a':1,'c':3},*{'b':2,'d':4})#a c b d
```

#### 生成器推导式

生成器推导式使用圆括号而不是列表推导式所使用的方括号。

```
g = ((i + 2)**2 for i in range(10))print(g)            #<generator object <genexpr> at 0x000001DC6A279510>print(tuple(g))     #(4, 9, 16, 25, 36, 49, 64, 81, 100, 121)'''生成器遍历一次就遍历结束'''print(tuple(g))     #()g = ((i + 2)**2 for i in range(10))print(list(g))      #[4, 9, 16, 25, 36, 49, 64, 81, 100, 121]'''单步迭代'''g = ((i + 2)**2 for i in range(10))print(g.__next__())     #4print(g.__next__())     #9print(g.__next__())     #16g = ((i + 2)**2 for i in range(10))for i in g:    print(i,end=' ')#4 9 16 25 36 49 64 81 100 121
```

## 使用字典

字典是“键-值对”的无序可变序列

字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。

字典中的“键”可以是Python中任意不可变数据，例如：整数，实数，复数，字符串，元组等，但不可以使用列表、集合、字典作为字典的“键”，因为这些类型的对象是可变的。另外，字典中的“键”不允许重复，而“值”是可以重复的。

使用内置函数```globals（）```返回和查看包含当前作用域内所有全局变量和值的字典使用类似函数```local（）```返回包含当前作用域内所有局部变量和值的字典。

```Python
# 创建字典的字面量语法
scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82}
print(scores)
# 创建字典的构造器语法
items1 = dict(one=1, two=2, three=3, four=4)
# 通过zip函数将两个序列压成字典
items2 = dict(zip(['a', 'b', 'c'], '123'))
# 创建字典的推导式语法
items3 = {num: num ** 2 for num in range(1, 10)}
print(items1, items2, items3)
# 通过键可以获取字典中对应的值
print(scores['骆昊'])
print(scores['狄仁杰'])
#通过get()方法获取指点“键”对应的“值”
print(score.get('狄仁杰'))
print(score.get('狄仁杰','NO'))#当“键”不存在的时候返回指定值
#字典元素的添加与修改
scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82}
scores['徐钦阳'] = 20
scores.update({'a':'a','b':'b'})
#'骆昊': 95, '白元芳': 78, '狄仁杰': 82,'a':'a','b':'b'
# 对字典中所有键值对进行遍历
for key in scores:
    print(f'{key}: {scores[key]}')
# 更新字典中的元素
scores['白元芳'] = 65
scores['诸葛王朗'] = 71
scores.update(冷面=67, 方启鹤=85)
print(scores)
if '武则天' in scores:
    print(scores['武则天'])
print(scores.get('武则天'))
# get方法也是通过键获取对应的值但是可以设置默认值
print(scores.get('武则天', 60))
# 删除字典中的元素
print(scores.popitem())
print(scores.popitem())
print(scores.pop('骆昊', 100))
# 清空字典
scores.clear()
print(scores)
```

#### 字典应用案例

###### 案例1

生成包含1000个随机字符的字符串，然后统计每个字符出现次数

```python
import string
import random
x = string.ascii_letters+string.digits+string.punctuation
print(x)
'''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
y = [random.choice(x) for i in range(1000)]
z = ''.join(y)
d = dict()
for ch in z:
    d[ch]=d.get(ch,0)+1
print(d)
'''
{'{': 16, 'v': 11, 'B': 7, 'S': 12, '1': 9, 'x': 7, '*': 12, ',': 8, 'M': 9, 's': 8, "'": 8, '6': 10, '@': 16, 'F': 13, ']': 13, '~': 17, 'P': 15, '\\': 12, 'V': 11, ':': 8, 'C': 13, 'q': 12, 'g': 14, 'R': 9, '8': 11, 'y': 14, 'X': 10, 'G': 14, 'k': 5, '"': 14, 'l': 13, 'J': 16, '$': 9, '>': 11, '9': 8, 'n': 7, 'h': 12, '<': 12, '.': 16, '|': 16, '3': 10, 'z': 9, '#': 11, 
'd': 12, 'a': 16, '=': 14, 'u': 10, 'T': 7, '7': 12, 'K': 11, '/': 11, '_': 13, '5': 16, 'o': 15, 'b': 16, '}': 12, '+': 10, ';': 13, 'c': 9, 'w': 10, 'E': 10, '-': 10, 'O': 7, '?': 9, 'L': 11, '&': 12, 'p': 10, 'f': 13, 'Q': 7, '^': 14, 'Z': 6, '(': 8, 'A': 12, 'm': 9, '%': 7, '0': 12, '!': 8, 'N': 13, 'i': 10, 'I': 6, '4': 13, '[': 4, 'W': 12, '2': 5, 'e': 6, 'Y': 8, 'j': 5, ')': 10, 'D': 7, 'H': 5, 'U': 9, '`': 13, 't': 10, 'r': 4}'''

'''使用collections模块的defaultdict类来实现该功能'''
import string
import random
x = string.ascii_letters+string.digits+string.punctuation
print(x)
'''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'''
y = [random.choice(x) for i in range(1000)]
z = ''.join(y)
from collections import defaultdict
frequences = defaultdict(int)
print(frequences)
'''defaultdict(<class 'int'>, {})'''
for item in z:
    frequences[item]+=1
print(frequences.items())
'''dict_items([(';', 7), ('g', 12), ('#', 10), (':', 6), ('b', 16), ('$', 16), ('~', 16), ('@', 13), ('?', 15), ('<', 10), ('Y', 6), ('\\', 16), ('=', 12), ('u', 9), ('R', 16), ('L', 15), ('S', 13), ('^', 9), ('t', 11), ('V', 15), ("'", 10), ('&', 10), ('.', 13), ('7', 12), ('f', 14), ('8', 8), ('X', 13), ('-', 15), ('1', 12), ('_', 13), ('N', 6), ('D', 7), ('T', 9), ('x', 11), ('s', 14), ('M', 10), ('{', 14), (')', 13), ('n', 16), ('m', 12), ('K', 12), ('C', 10), (']', 13), ('P', 7), ('c', 9), ('p', 13), ('/', 13), ('F', 7), ('`', 9), ('y', 15), ('v', 18), ('B', 14), ('}', 10), ('r', 6), ('o', 11), ('W', 9), ('k', 9), ('9', 9), ('|', 4), ('0', 16), ('+', 11), ('Z', 6), ('U', 13), ('l', 9), ('[', 14), ('6', 12), ('E', 10), ('J', 7), ('I', 13), ('i', 10), ('A', 10), ('w', 6), ('H', 12), ('(', 12), ('O', 8), ('G', 6), ('%', 10), (',', 7), ('5', 11), ('3', 7), ('Q', 10), ('"', 5), ('e', 8), ('>', 14), ('2', 10), ('q', 6), ('z', 10), ('d', 7), ('!', 6), ('h', 7), ('4', 7), ('a', 7), ('j', 10), ('*',10)])'''


'''使用collection模块的Counter类查找出现次数最多的元素'''
import string
import random
x = string.ascii_letters+string.digits+string.punctuation
print(x)
y = [random.choice(x) for i in range(1000)]
z = ''.join(y)
from collections import Counter
frequences = Counter(z)
print(frequences.items())
print(frequences.most_common(3))
#[('/', 17), ('e', 17), ('Z', 17)]
```

#### 字典推导式

```python
a={i:str(i) for i in range(1,5)}
print(a)		#{1: '1', 2: '2', 3: '3', 4: '4'}
x=['A','B','C','D']
y=['a','b','c','d']
print({i:j for i,j in zip(x,y)})
#{'A': 'a', 'B': 'b', 'C': 'c', 'D': 'd'}
```

##### 有序字典

python内置字典是无序的，```collection.OrderedDict```是有序的

```python
import collections
x = collections.OrderedDict()
x['a'] = 3
x['b'] = 5
x['c'] = 8
print(x)#OrderedDict([('a', 3), ('b', 5), ('c', 8)])
```

### 内置方法sorted       （from operator import itemgetter）

列表提供了```sorted()```方法支持原地排序，而内置函数```sorted()```返回新的列表，并不对源列表做任何修改。除此之外，```sorted()```方法可以对元组，字典排序，并且借助于其```key```参数，可以实现复杂的排序。

```python
persons = [{'name':'Dong','age':37},{'name':'Zhang','age':40},{'name'
:'Li','age':50},{'name':'Dong','age':43}]
print(persons)
#[{'name': 'Dong', 'age': 37}, {'name': 'Zhang', 'age': 40}, {'name': 'Li', 'age': 50}, {'name': 'Dong', 'age': 43}]
print(sorted(persons,key=lambda x:(x['name'],-x['age'])))
#[{'name': 'Dong', 'age': 43}, {'name': 'Dong', 'age': 37}, {'name': 'Li', 'age': 50}, {'name': 'Zhang', 'age': 40}]

#itemgetter(1)按照字典中的元素值排序
#把字典里面的内容看作在一个列表里面[linda，7750]
#itemgetter(1)就是指以列表中位序为1的元素作为排序依据
phonebook = {'Linda':'7750','Bob':'9345','Carol':'5834'}
from operator import itemgetter
print(sorted(phonebook.items(),key=itemgetter(1)))
#[('Carol', '5834'), ('Linda', '7750'), ('Bob', '9345')]

#itemgetter(0)按照字典中的元素键排序
phonebook = {'Linda':'7750','Bob':'9345','Carol':'5834'}
from operator import itemgetter
print(sorted(phonebook.items(),key=itemgetter(0)))
#[('Bob', '9345'), ('Carol', '5834'), ('Linda', '7750')]

#itemgetter(0，1)按照姓名升序，姓名相同按分数升序排序
#把字典里面的内容看作在一个列表里面['Bob',95.0,'A']
#itemgetter(0，1)就是指以列表中位序为0的元素作为排序依据即按照名字排序，在0的基础上按照1为排序的依据
gameresult = [['Bob',95.0,'A'],['Alan',86.0,'C'],['Mandy',83.5,'A'],['Rob',89.3,'E']]
from operator import itemgetter
print(sorted(gameresult,key=itemgetter(0,1)))
#[['Alan', 86.0, 'C'], ['Bob', 95.0, 'A'], ['Mandy', 83.5, 'A'], ['Rob', 89.3, 'E']]

#itemgetter(1，0)按照分数升序，分数相同按姓名升序排序
gameresult = [['Bob',95.0,'A'],['Alan',86.0,'C'],['Mandy',83.5,'A'],['Rob',89.3,'E']]
from operator import itemgetter
print(sorted(gameresult,key=itemgetter(1,0)))
#[['Mandy', 83.5, 'A'], ['Alan', 86.0, 'C'], ['Rob', 89.3, 'E'], ['Bob', 95.0, 'A']]
list1=["what","I'm","sorting","boy"]
list2=["something","else","to","sort"]
pairs=zip(list1,list2)
pairs=sorted(pairs)
print(pairs)
result = [x[1] for x in pairs]
print(result)
```

## 使用集合

Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。集合中每一个元素都是唯一的。

![](C:/Users/tony5/Desktop/python/Python-100-Days/Day01-15/res/python-set.png)

可以按照下面代码所示的方式来创建和使用集合。

```Python
# 创建集合的字面量语法
set1 = {1, 2, 3, 3, 3, 2}
print(set1)	#{1, 2, 3}可见集合中每一个元素都是唯一的
print('Length =', len(set1))	#Length = 3
# 创建集合的构造器语法(面向对象部分会进行详细讲解)
set2 = set(range(1, 10))
set3 = set((1, 2, 3, 3, 2, 1))
print(set2, set3)
#{1, 2, 3, 4, 5, 6, 7, 8, 9} {1, 2, 3}
# 创建集合的推导式语法(推导式也可以用于推导集合)
set4 = {num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0}
print(set4)
#{3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24, 25, 27, 30, 33, 35, 36, 39, 40, 42, 45, 48, 50, 51, 54, 55, 57, 60, 63, 65, 66, 69, 70, 72, 75, 78, 80, 81, 84, 85, 87, 90, 93, 95, 96, 99}
```

向集合添加元素和从集合删除元素。

```Python
set1.add(4)
set1.add(5)
set2.update([11, 12])
set2.discard(5)
if 4 in set2:
    set2.remove(4)
print(set1, set2)		#{1, 2, 3, 4, 5} {1, 2, 3, 6, 7, 8, 9, 11, 12}
print(set3.pop())		#1
print(set3)			    #{2, 3}
```

集合的成员、交集、并集、差集等运算。

```Python
# 集合的交集、并集、差集、对称差运算
print(set1 & set2)
# print(set1.intersection(set2))
print(set1 | set2)
# print(set1.union(set2))
print(set1 - set2)
# print(set1.difference(set2))
print(set1 ^ set2)
# print(set1.symmetric_difference(set2))
# 判断子集和超集
print(set2 <= set1)
# print(set2.issubset(set1))
print(set3 <= set1)
# print(set3.issubset(set1))
print(set1 >= set2)
# print(set1.issuperset(set2))
print(set1 >= set3)
# print(set1.issuperset(set3))

aset = set([8,9,10,11,12,13])
bset = set([0,1,2,3,7,8])
print(aset | bset)					#并集{0, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13}
print(aset.union(bset))			 	 #并集{0, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13}
print(aset & bset)						#交集{8}
print(aset.intersection(bset))		 	 #交集{8}
print(aset.difference(bset))			 #差集{9, 10, 11, 12, 13}
print(aset - bset)						#差集{9, 10, 11, 12, 13}
print(aset.symmetric_difference(bset))
									#对称差{0, 1, 2, 3, 7, 9, 10, 11, 12, 13}
print(aset^bset)					 #对称差{0, 1, 2, 3, 7, 9, 10, 11, 12, 13}
'''集合比大小'''
x = {1,2,3}
y = {1,2,5}
z = {1,2,3,4}
print(x<y)		#False
print(x<z)		#True
print(x.issubset(y))        #False
print(x.issubset(z))        #True
```

> **说明：** Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如`&`运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。

作为集合的具体应用，可以使用集合快速提取序列中的单一元素，即提取出序列中所有不重复元素，如果使用传统方式，则需要使用一下代码

```python
import random
listRandom = [random.randint(0,9999) for i in range(100)]
noRepeat = []
for i in listRandom:
    if i not in noRepeat:
        noRepeat.append(i)
print(len(listRandom))			#100
print(len(noRepeat))			#98
```

#### 集合综合案例

案例1：生成不重复随机数的效率比较

```python
import random
import time

def RandomNumbers(number,start,end):
    "使用列表来生成number个介于start和end之间不重复的随机数"
    data = []
    n=0
    while True:
        element = random.randint(start,end)
        if element not in data:
            data.append(element)
            n+=1
        if n == number-1:
            break
    return data
def RandomNumbers1(number,start,end):
    "使用列表来生成number个介于start和end之间不重复的随机数"
    data = []
    while True:
        element = random.randint(start,end)
        if element not in data:
            data.append(element)
        if len(data)==number:
            break
    return data
def RandomNumbers2(number,start,end):
    "使用集合来生成number个介于start和end之间不重复随机数"
    data = set()
    while True:
        data.add(random.randint(start,end))
        if len(data) == number:
            break
    return data

import time
timediffer = {"函数":"所用时间"}
start = time.time()
RandomNumbers(10000,0,9999)
timediffer["列表方法1"]=time.time()-start
start = time.time()
RandomNumbers1(10000,0,9999)
timediffer["列表方法2"]=time.time()-start
start = time.time()
RandomNumbers2(10000,0,9999)
timediffer["集合方法"]=time.time()-start
print(timediffer)
#{'函数': '所用时间', '列表方法1': 4.940783262252808, '列表方法2':5.175156116485596, '集合方法': 0.08477330207824707}

```

## 复杂数据结构

### 堆

堆是一种重要的数据结构，在进行排序时使用较多，优先队列也是堆结构的一个重要应用。堆是一个二叉树，其中每个父结点的值都小于其所有子节点的值。使用数组或列表实现堆时，对于所有的k（下标，从0开始）都满足heap[k]<=heap[2*k+1]和heap[k]<=heap[2*k+2],即每一棵子树的根小于所有子结点。

python在**```heapq```**模块中提供了对堆的支持。

```python
import heapq
import random
data = list(range(10))
random.shuffle(data)
print(data)		#[0, 2, 9, 8, 7, 3, 5, 4, 1, 6]
heap = []
for n in data:
    heapq.heappush(heap,n)
print(heap)		#[0, 1, 3, 2, 6, 9, 5, 8, 4, 7]
heapq.heappush(heap,0.5)
print(heap)	#[0, 0.5, 3, 2, 1, 9, 5, 8, 4, 7, 6]
print(heapq.heappop(heap))	#0
print(heapq.heappop(heap))	#0.5
print(heap)		#[1, 2, 3, 4, 6, 9, 5, 8, 7]
'''将列表转换成堆'''
import heapq
import random
myheap = [1,2,3,4,5,6,7,8,9,4,10,333]
print(myheap)
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 4, 10, 333]
heapq.heapreplace(myheap,6)
print(myheap)
#[2, 4, 3, 6, 5, 6, 7, 8, 9, 4, 10, 333]
print(heapq.nlargest(3,myheap))		#[333, 10, 9]
print(heapq.nsmallest(3,myheap))	#[2, 3, 4]
```

### 队列

队列的特性是先进先出和后进后出，python提供了Queue模块和```collections.deque```模块支持队列的操作

```python 
'''后进先出'''
import queue
LiFoQueue = queue.LifoQueue(5)
LiFoQueue.put(1)
LiFoQueue.put(2)
LiFoQueue.put(3)
print(LiFoQueue.get())	#3
print(LiFoQueue.get())	#2
print(LiFoQueue.get())	#1
'''先进先出'''
import queue
PriQueue = queue.PriorityQueue(5)
PriQueue.put(3)
PriQueue.put(5)
PriQueue.put(1)
PriQueue.put(8)
print(PriQueue.queue)	#[1, 5, 3, 8]
print(PriQueue.get())	#1
print(PriQueue.get())	#3
print(PriQueue.get())	#5
print(PriQueue.get())	#8
```

### 栈

栈是一种“后进先出”或者“先进后出”的数据结构，Python列表本身就可以实现栈结构的基本操作。例如，列表对象的```append()```方法是在列表尾部追加元素，类似于入栈元素操作。列表对象的```pop()```方法默认是弹出并返回列表的最后一个元素，类似于出栈操作。但是使用python列表对象模拟栈操作并不是很方便，例如列表为空时执行出栈操作```pop()```会抛出一个很不友好的异常，另外也无法限制栈的大小。

```python
myStack = []
myStack.append(3)
myStack.append(5)
myStack.append(7)
print(myStack)      #[3, 5, 7]
myStack.pop()
myStack.pop()
print(myStack)      #[3]
myStack.pop()
myStack.pop()
print(myStack)      #IndexError: pop from empty list
```

### 链表

可以直接使用列表及其基本操作来实现链表的功能，可以很方便地实现链表创建以及节点的插入和删除操作。

```python
linkTable = []
linkTable.append(3)
linkTable.append(5)
print(linkTable)            #[3, 5]
linkTable.insert(1,4)
print(linkTable)            #[3, 4, 5]
linkTable.remove(linkTable[1])
print(linkTable)            #[3, 5]
```















